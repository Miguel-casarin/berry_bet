import {
  __toESM,
  require_react
} from "./chunk-V62QEVPD.js";

// node_modules/react-horizontal-scrolling-menu/dist/index.mjs
var import_react = __toESM(require_react(), 1);
var t = "react-horizontal-scrolling-menu";
var n = `${t}--item`;
var r = `${t}--scroll-container`;
var o = `${t}--wrapper`;
var s = `${t}--inner-wrapper`;
var i = `${t}--header`;
var l = `${t}--arrow-left`;
var a = `${t}--arrow-right`;
var u = `${t}--footer`;
var c = "itemId";
var d = "data-key";
var h = "data-index";
var f = { first: "first", last: "last", onInit: "onInit", onUpdate: "onUpdate" };
var v = "";
var m = { current: null };
var p = Object.freeze({ __proto__: null, rootClassName: t, itemClassName: n, scrollContainerClassName: r, wrapperClassName: o, innerWrapperClassName: s, headerClassName: i, arrowLeftClassName: l, arrowRightClassName: a, footerClassName: u, id: c, dataKeyAttribute: d, dataIndexAttribute: h, events: f, emptyStr: v, emptyRef: m });
var b = class {
  constructor() {
    this.subscribe = (e2, t2) => {
      this.observers.set(e2, (this.observers.get(e2) || []).concat(t2));
    }, this.unsubscribe = (e2, t2) => {
      const n2 = (this.observers.get(e2) || []).filter((e3) => e3 !== t2);
      n2.length ? this.observers.set(e2, n2) : this.observers.delete(e2);
    }, this.emitUpdates = (e2, t2) => {
      const n2 = this.observers.get(e2) || [];
      null == n2 || n2.forEach((e3) => e3(t2));
    }, this.updateBatch = (e2, t2 = true) => {
      e2.length && (e2.forEach(([e3, t3]) => this.emitUpdates(e3, t3)), t2 && this.emitUpdates(f.onUpdate));
    }, this.update = (e2, t2) => {
      this.emitUpdates(e2, t2), this.emitUpdates(f.onUpdate);
    }, this.observers = /* @__PURE__ */ new Map();
  }
};
var g = class extends Map {
  constructor() {
    super(), this.subscribe = (e2, t2) => this.observer.subscribe(e2, t2), this.unsubscribe = (e2, t2) => this.observer.unsubscribe(e2, t2), this.isEdgeItem = ({ key: e2, value: t2, first: n2 = this.first(), last: r2 = this.last() }) => {
      const o2 = [];
      return e2 === (null == n2 ? void 0 : n2.key) ? o2.push([f.first, t2]) : e2 === (null == r2 ? void 0 : r2.key) && o2.push([f.last, t2]), o2;
    }, this.edgeItemsCheck = (e2) => {
      const t2 = this.first(), n2 = this.last(), r2 = e2.find(([e3]) => e3 === (null == t2 ? void 0 : t2.key)), o2 = [];
      r2 && o2.push([f.first, r2[1]]);
      const s2 = e2.find(([e3]) => e3 === (null == n2 ? void 0 : n2.key));
      return s2 && o2.push([f.last, s2[1]]), o2;
    }, this.toArr = () => this.sort([...this]), this.toItems = () => this.toArr().map(([e2]) => e2), this.sort = (e2) => e2.sort(([, e3], [, t2]) => +e3.index - +t2.index), this.set = (e2, t2) => {
      const n2 = String(e2), r2 = [[n2, t2]];
      return super.set(n2, t2), r2.push(...this.isEdgeItem({ key: n2, value: t2, first: this.first(), last: this.last() })), this.observer.updateBatch(r2), this;
    }, this.setBatch = (e2) => {
      this.firstRun && this.observer.update(f.onInit);
      const t2 = [...e2];
      return this.sort(t2).forEach(([e3, t3]) => {
        super.set(String(e3), t3);
      }), t2.push(...this.edgeItemsCheck(t2)), this.observer.updateBatch(t2, !this.firstRun), this.firstRun = false, this;
    }, this.first = () => {
      var e2;
      return null === (e2 = this.toArr()[0]) || void 0 === e2 ? void 0 : e2[1];
    }, this.last = () => {
      var e2, t2;
      return null === (t2 = null === (e2 = this.toArr().slice(-1)) || void 0 === e2 ? void 0 : e2[0]) || void 0 === t2 ? void 0 : t2[1];
    }, this.filter = (e2) => this.toArr().filter(e2), this.find = (e2) => this.toArr().find(e2), this.findIndex = (e2) => this.toArr().findIndex(e2), this.getCurrentPos = (e2) => {
      const t2 = this.toArr(), n2 = t2.findIndex(([t3, n3]) => t3 === e2 || n3 === e2);
      return [t2, n2];
    }, this.prev = (e2) => {
      var t2;
      const [n2, r2] = this.getCurrentPos(e2);
      return -1 !== r2 ? null === (t2 = n2[r2 - 1]) || void 0 === t2 ? void 0 : t2[1] : void 0;
    }, this.next = (e2) => {
      var t2;
      const [n2, r2] = this.getCurrentPos(e2);
      return -1 !== r2 ? null === (t2 = n2[r2 + 1]) || void 0 === t2 ? void 0 : t2[1] : void 0;
    }, this.getVisible = () => this.filter((e2) => e2[1].visible), this.observer = new b(), this.firstRun = true;
  }
};
var y = (e2) => "object" == typeof e2 && null != e2 && 1 === e2.nodeType;
var w = (e2, t2) => (!t2 || "hidden" !== e2) && "visible" !== e2 && "clip" !== e2;
var C = (e2, t2) => {
  if (e2.clientHeight < e2.scrollHeight || e2.clientWidth < e2.scrollWidth) {
    const n2 = getComputedStyle(e2, null);
    return w(n2.overflowY, t2) || w(n2.overflowX, t2) || ((e3) => {
      const t3 = ((e4) => {
        if (!e4.ownerDocument || !e4.ownerDocument.defaultView) return null;
        try {
          return e4.ownerDocument.defaultView.frameElement;
        } catch (e5) {
          return null;
        }
      })(e3);
      return !!t3 && (t3.clientHeight < e3.scrollHeight || t3.clientWidth < e3.scrollWidth);
    })(e2);
  }
  return false;
};
var M = (e2, t2, n2, r2, o2, s2, i2, l2) => s2 < e2 && i2 > t2 || s2 > e2 && i2 < t2 ? 0 : s2 <= e2 && l2 <= n2 || i2 >= t2 && l2 >= n2 ? s2 - e2 - r2 : i2 > t2 && l2 < n2 || s2 < e2 && l2 > n2 ? i2 - t2 + o2 : 0;
var E = (e2) => {
  const t2 = e2.parentElement;
  return null == t2 ? e2.getRootNode().host || null : t2;
};
var I = (e2, t2) => {
  var n2, r2, o2, s2;
  if ("undefined" == typeof document) return [];
  const { scrollMode: i2, block: l2, inline: a2, boundary: u2, skipOverflowHiddenElements: c2 } = t2, d2 = "function" == typeof u2 ? u2 : (e3) => e3 !== u2;
  if (!y(e2)) throw new TypeError("Invalid target");
  const h2 = document.scrollingElement || document.documentElement, f2 = [];
  let v2 = e2;
  for (; y(v2) && d2(v2); ) {
    if (v2 = E(v2), v2 === h2) {
      f2.push(v2);
      break;
    }
    null != v2 && v2 === document.body && C(v2) && !C(document.documentElement) || null != v2 && C(v2, c2) && f2.push(v2);
  }
  const m2 = null != (r2 = null == (n2 = window.visualViewport) ? void 0 : n2.width) ? r2 : innerWidth, p2 = null != (s2 = null == (o2 = window.visualViewport) ? void 0 : o2.height) ? s2 : innerHeight, { scrollX: b2, scrollY: g2 } = window, { height: w2, width: I2, top: k2, right: x2, bottom: N2, left: R2 } = e2.getBoundingClientRect(), { top: S2, right: T2, bottom: $2, left: O2 } = ((e3) => {
    const t3 = window.getComputedStyle(e3);
    return { top: parseFloat(t3.scrollMarginTop) || 0, right: parseFloat(t3.scrollMarginRight) || 0, bottom: parseFloat(t3.scrollMarginBottom) || 0, left: parseFloat(t3.scrollMarginLeft) || 0 };
  })(e2);
  let B2 = "start" === l2 || "nearest" === l2 ? k2 - S2 : "end" === l2 ? N2 + $2 : k2 + w2 / 2 - S2 + $2, W2 = "center" === a2 ? R2 + I2 / 2 - O2 + T2 : "end" === a2 ? x2 + T2 : R2 - O2;
  const j2 = [];
  for (let e3 = 0; e3 < f2.length; e3++) {
    const t3 = f2[e3], { height: n3, width: r3, top: o3, right: s3, bottom: u3, left: c3 } = t3.getBoundingClientRect();
    if ("if-needed" === i2 && k2 >= 0 && R2 >= 0 && N2 <= p2 && x2 <= m2 && k2 >= o3 && N2 <= u3 && R2 >= c3 && x2 <= s3) return j2;
    const d3 = getComputedStyle(t3), v3 = parseInt(d3.borderLeftWidth, 10), y2 = parseInt(d3.borderTopWidth, 10), C2 = parseInt(d3.borderRightWidth, 10), E2 = parseInt(d3.borderBottomWidth, 10);
    let S3 = 0, T3 = 0;
    const $3 = "offsetWidth" in t3 ? t3.offsetWidth - t3.clientWidth - v3 - C2 : 0, O3 = "offsetHeight" in t3 ? t3.offsetHeight - t3.clientHeight - y2 - E2 : 0, H2 = "offsetWidth" in t3 ? 0 === t3.offsetWidth ? 0 : r3 / t3.offsetWidth : 0, L2 = "offsetHeight" in t3 ? 0 === t3.offsetHeight ? 0 : n3 / t3.offsetHeight : 0;
    if (h2 === t3) S3 = "start" === l2 ? B2 : "end" === l2 ? B2 - p2 : "nearest" === l2 ? M(g2, g2 + p2, p2, y2, E2, g2 + B2, g2 + B2 + w2, w2) : B2 - p2 / 2, T3 = "start" === a2 ? W2 : "center" === a2 ? W2 - m2 / 2 : "end" === a2 ? W2 - m2 : M(b2, b2 + m2, m2, v3, C2, b2 + W2, b2 + W2 + I2, I2), S3 = Math.max(0, S3 + g2), T3 = Math.max(0, T3 + b2);
    else {
      S3 = "start" === l2 ? B2 - o3 - y2 : "end" === l2 ? B2 - u3 + E2 + O3 : "nearest" === l2 ? M(o3, u3, n3, y2, E2 + O3, B2, B2 + w2, w2) : B2 - (o3 + n3 / 2) + O3 / 2, T3 = "start" === a2 ? W2 - c3 - v3 : "center" === a2 ? W2 - (c3 + r3 / 2) + $3 / 2 : "end" === a2 ? W2 - s3 + C2 + $3 : M(c3, s3, r3, v3, C2 + $3, W2, W2 + I2, I2);
      const { scrollLeft: e4, scrollTop: i3 } = t3;
      S3 = 0 === L2 ? 0 : Math.max(0, Math.min(i3 + S3 / L2, t3.scrollHeight - n3 / L2 + O3)), T3 = 0 === H2 ? 0 : Math.max(0, Math.min(e4 + T3 / H2, t3.scrollWidth - r3 / H2 + $3)), B2 += i3 - S3, W2 += e4 - T3;
    }
    j2.push({ el: t3, top: S3, left: T3 });
  }
  return j2;
};
function k(e2, t2) {
  if (!e2.isConnected || !((e3) => {
    let t3 = e3;
    for (; t3 && t3.parentNode; ) {
      if (t3.parentNode === document) return true;
      t3 = t3.parentNode instanceof ShadowRoot ? t3.parentNode.host : t3.parentNode;
    }
    return false;
  })(e2)) return;
  const n2 = ((e3) => {
    const t3 = window.getComputedStyle(e3);
    return { top: parseFloat(t3.scrollMarginTop) || 0, right: parseFloat(t3.scrollMarginRight) || 0, bottom: parseFloat(t3.scrollMarginBottom) || 0, left: parseFloat(t3.scrollMarginLeft) || 0 };
  })(e2);
  if (((e3) => "object" == typeof e3 && "function" == typeof e3.behavior)(t2)) return t2.behavior(I(e2, t2));
  const r2 = "boolean" == typeof t2 || null == t2 ? void 0 : t2.behavior;
  for (const { el: o2, top: s2, left: i2 } of I(e2, ((e3) => false === e3 ? { block: "end", inline: "nearest" } : ((e4) => e4 === Object(e4) && 0 !== Object.keys(e4).length)(e3) ? e3 : { block: "start", inline: "nearest" })(t2))) {
    const e3 = s2 - n2.top + n2.bottom, t3 = i2 - n2.left + n2.right;
    o2.scroll({ top: e3, left: t3, behavior: r2 });
  }
}
var x;
var N = () => (x || (x = "performance" in window ? performance.now.bind(performance) : Date.now), x());
function R(e2) {
  const t2 = N(), n2 = Math.min((t2 - e2.startTime) / e2.duration, 1), r2 = e2.ease(n2), o2 = e2.startX + (e2.x - e2.startX) * r2, s2 = e2.startY + (e2.y - e2.startY) * r2;
  e2.method(o2, s2, n2, r2), o2 !== e2.x || s2 !== e2.y ? requestAnimationFrame(() => R(e2)) : e2.cb();
}
function S(e2, t2, n2) {
  let r2 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 600, o2 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : (e3) => 1 + --e3 * e3 * e3 * e3 * e3, s2 = arguments.length > 5 ? arguments[5] : void 0, i2 = arguments.length > 6 ? arguments[6] : void 0;
  const l2 = e2, a2 = e2.scrollLeft, u2 = e2.scrollTop;
  R({ scrollable: l2, method: (t3, n3, r3, o3) => {
    const s3 = Math.ceil(t3), l3 = Math.ceil(n3);
    e2.scrollLeft = s3, e2.scrollTop = l3, null == i2 || i2({ target: e2, elapsed: r3, value: o3, left: s3, top: l3 });
  }, startTime: N(), startX: a2, startY: u2, x: t2, y: n2, duration: r2, ease: o2, cb: s2 });
}
var T = function(e2, t2) {
  const n2 = t2 || {};
  return ((e3) => e3 && !e3.behavior || "smooth" === e3.behavior)(n2) ? k(e2, { block: n2.block, inline: n2.inline, scrollMode: n2.scrollMode, boundary: n2.boundary, skipOverflowHiddenElements: n2.skipOverflowHiddenElements, behavior: (e3) => Promise.all(e3.reduce((e4, t3) => {
    let { el: r2, left: o2, top: s2 } = t3;
    const i2 = r2.scrollLeft, l2 = r2.scrollTop;
    return i2 === o2 && l2 === s2 ? e4 : [...e4, new Promise((e5) => S(r2, o2, s2, n2.duration, n2.ease, () => e5({ el: r2, left: [i2, o2], top: [l2, s2] }), n2.onScrollChange))];
  }, [])) }) : Promise.resolve(k(e2, t2));
};
var $ = (e2) => Object.values(e2).map((e3) => e3.current).filter(Boolean);
function O(e2, t2, n2, r2, o2, s2) {
  var i2;
  const l2 = (null === (i2 = null == e2 ? void 0 : e2.entry) || void 0 === i2 ? void 0 : i2.target) || e2;
  if (!l2) return;
  const a2 = { behavior: t2 || "smooth", inline: n2 || "end", block: r2 || "nearest" };
  return s2 ? l2.scrollIntoView(a2) : T(l2, Object.assign(Object.assign({}, o2), a2));
}
var B = (e2) => document.querySelector(`[${d}='${e2}']`);
var W = (e2) => document.querySelector(`[${h}='${e2}']`);
function j(t2) {
  return import_react.default.isValidElement(t2) && t2 || "function" == typeof t2 && import_react.default.createElement(t2, null) || !!t2 && "object" == typeof t2 && import_react.default.createElement(t2, null) || null;
}
var H = (e2) => {
  var t2;
  return String((null === (t2 = null == e2 ? void 0 : e2.props) || void 0 === t2 ? void 0 : t2[c]) || ((null == e2 ? void 0 : e2.key) || v).replace(/^\.\$/, v));
};
function L(e2) {
  return !!e2 && Object.prototype.hasOwnProperty.call(e2, "current");
}
var U = import_react.default.memo(function({ children: t2, className: n2, id: r2, index: o2, refs: s2 }) {
  const i2 = import_react.default.useRef(null);
  return s2[String(o2)] = i2, import_react.default.createElement("div", { className: n2, [d]: r2, [h]: o2, ref: i2 }, t2);
});
function V({ children: t2, itemClassName: r2 = v, refs: o2 }) {
  const s2 = import_react.default.Children.toArray(t2).filter(Boolean), i2 = import_react.default.useMemo(() => `${n} ${r2}`, [r2]);
  return s2.map((t3, n2) => {
    const r3 = H(t3);
    return import_react.default.createElement(U, { className: i2, id: r3, key: r3, refs: o2, index: n2 }, t3);
  });
}
function A({ className: t2 = v, children: n2, onScroll: o2 = () => {
}, scrollRef: s2, containerRef: i2 }) {
  const l2 = import_react.default.useMemo(() => `${r} ${t2}`, [t2]), a2 = import_react.default.useCallback((e2) => {
    L(s2) ? s2.current = e2 : s2(e2), L(i2) ? i2.current = e2 : i2(e2);
  }, [s2, i2]);
  return import_react.default.createElement("div", { className: l2, onScroll: o2, ref: a2 }, n2);
}
var P = import_react.default.createContext({});
var F = (e2) => {
  var t2;
  const n2 = e2[Math.floor(e2.length / 2)];
  return { first: null == e2 ? void 0 : e2[0], center: n2, last: null === (t2 = e2.slice(-1)) || void 0 === t2 ? void 0 : t2[0] };
};
var D = "undefined" != typeof window ? import_react.default.useLayoutEffect : import_react.default.useEffect;
function X({ items: t2, itemsChanged: n2, refs: r2, options: o2, wrapperVisible: s2 }) {
  const i2 = import_react.default.useRef(), { schedule: l2, add: a2, addPriority: u2, cleanup: c2 } = Y(t2, s2), d2 = import_react.default.useCallback((e2) => {
    const t3 = function(e3, t4) {
      return [...e3].map((e4) => {
        var n3, r3, o3, s3;
        const i3 = e4.target, l3 = String(null !== (r3 = null === (n3 = null == i3 ? void 0 : i3.dataset) || void 0 === n3 ? void 0 : n3.key) && void 0 !== r3 ? r3 : v);
        return [l3, { index: String(null !== (s3 = null === (o3 = null == i3 ? void 0 : i3.dataset) || void 0 === o3 ? void 0 : o3.index) && void 0 !== s3 ? s3 : v), key: l3, entry: e4, visible: e4.intersectionRatio >= t4.ratio }];
      });
    }(e2, o2);
    s2.current ? u2(t3) : a2(t3), l2();
  }, [o2, s2, u2, l2, a2]);
  D(() => {
    const e2 = $(r2), t3 = i2.current || new IntersectionObserver(d2, o2);
    return i2.current = t3, e2.forEach((e3) => t3.observe(e3)), () => {
      t3.disconnect(), i2.current = void 0, c2();
    };
  }, [d2, n2, o2, r2, c2]);
}
var Y = (t2, n2) => {
  const r2 = import_react.default.useRef([]), o2 = import_react.default.useRef([]), s2 = import_react.default.useRef(0), i2 = import_react.default.useRef(false), l2 = import_react.default.useCallback(() => n2.current, [n2]), a2 = import_react.default.useCallback(() => {
    clearTimeout(s2.current), i2.current = false;
  }, [s2, i2]), u2 = import_react.default.useCallback(() => {
    if (!l2()) return a2(), void c2();
    t2.setBatch(_(r2.current, q(o2.current)));
  }, [a2, r2, o2, l2, t2]), c2 = import_react.default.useCallback(() => {
    i2.current || (i2.current = true, s2.current = setTimeout(() => {
      u2(), r2.current = [], o2.current = [], i2.current = false;
    }, l2() ? 0 : 100));
  }, [u2, o2, r2, l2]), d2 = import_react.default.useCallback(() => {
    a2(), r2.current = [], o2.current = [];
  }, [o2, r2, a2]), h2 = import_react.default.useCallback((e2) => {
    a2(), r2.current.push(...e2), c2();
  }, [r2, c2, a2]), f2 = import_react.default.useCallback((e2) => {
    a2(), o2.current.push(...e2), c2();
  }, [o2, c2, a2]);
  return { schedule: c2, add: h2, addPriority: f2, running: i2, cleanup: d2 };
};
var _ = (e2, t2) => q(e2).filter((e3) => !t2.find((t3) => t3[0] === e3[0])).concat(t2);
var q = (e2) => {
  const t2 = [];
  return e2.reverse().forEach((e3) => {
    t2.find((t3) => t3[0] === e3[0]) || t2.push(e3);
  }), t2.reverse();
};
var z = (t2) => import_react.default.Children.toArray(t2).map(H).filter(Boolean);
var K = { ratio: 0.9, rootMargin: "5px", threshold: [0.05, 0.5, 0.75, 0.95] };
function G(e2, t2) {
  return { prev: () => function(e3, t3) {
    const n2 = e3.findIndex((e4) => e4 === (null == t3 ? void 0 : t3[0])), r2 = t3.length, o2 = n2 - r2, s2 = o2 < 0, i2 = s2 ? 0 : o2, l2 = e3.slice(i2, s2 ? r2 : n2);
    return l2.length === r2 ? l2 : e3.slice(n2, r2);
  }(e2, t2), next: () => function(e3, t3) {
    const n2 = e3.findIndex((e4) => {
      var n3;
      return e4 === (null === (n3 = t3.slice(-1)) || void 0 === n3 ? void 0 : n3[0]);
    }), r2 = t3.length, o2 = n2 + r2 + 1, s2 = o2 > e3.length - 1, i2 = s2 ? e3.length - 1 : o2, l2 = e3.slice(s2 ? i2 - r2 + 1 : n2 + 1, i2);
    return l2.length === r2 ? l2 : e3.slice(e3.length - r2, e3.length + r2);
  }(e2, t2) };
}
var J = { current: {} };
var Q = () => {
};
function Z({ LeftArrow: t2, RightArrow: n2, children: r2, Header: c2, Footer: d2, transitionDuration: h2 = 500, transitionBehavior: p2, onInit: b2 = Q, onUpdate: y2 = Q, onMouseDown: w2, onMouseLeave: C2, onMouseUp: M2, onMouseMove: E2, onScroll: I2 = Q, onTouchMove: k2, onTouchStart: x2, onTouchEnd: N2, onWheel: R2 = Q, options: S2 = K, scrollContainerClassName: T2 = v, containerRef: $2 = m, itemClassName: H2 = v, wrapperClassName: U2 = v, apiRef: F2 = J, RTL: Y2, noPolyfill: _2 }) {
  const q2 = j(t2), G2 = j(n2), Z2 = j(c2), ee = j(d2), te = import_react.default.useRef(null), [ne] = import_react.default.useState({}), re = import_react.default.useMemo(() => Object.assign(Object.assign(Object.assign({}, K), S2), { root: te.current }), [S2]), oe = import_react.default.useRef(new g()).current, se = function(t3, n3) {
    const [r3, o2] = import_react.default.useState(v), s2 = import_react.default.useMemo(() => z(t3), [t3]);
    return import_react.default.useEffect(() => {
      const e2 = s2.filter(Boolean).join(v);
      n3.toItems().filter((e3) => !s2.includes(e3)).forEach((e3) => {
        n3.delete(e3);
      }), o2(e2);
    }, [s2, n3]), r3;
  }(r2, oe), ie = import_react.default.useRef(null), le = ((t3, n3) => {
    const r3 = import_react.default.useRef(true), o2 = import_react.default.useMemo(() => n3 + 0.01, [n3]), s2 = import_react.default.useMemo(() => [o2 - 0.01, o2, o2 + 0.01], [o2]), i2 = import_react.default.useCallback((e2) => {
      var t4;
      const n4 = (null === (t4 = null == e2 ? void 0 : e2[0]) || void 0 === t4 ? void 0 : t4.intersectionRatio) > o2;
      r3.current !== n4 && (r3.current = n4);
    }, [o2]);
    return D(() => {
      const e2 = new IntersectionObserver(i2, { threshold: s2 });
      return t3.current && e2.observe(t3.current), () => {
        e2.disconnect();
      };
    }, [r3, t3, i2, s2]), r3;
  })(ie, re.ratio);
  X(import_react.default.useMemo(() => ({ items: oe, itemsChanged: se, options: re, refs: ne, wrapperVisible: le }), [oe, se, le, ne, re]));
  const ae = import_react.default.useMemo(() => function(t3, n3, r3) {
    var o2, s2, i2;
    const l2 = !!(null === (o2 = t3.first()) || void 0 === o2 ? void 0 : o2.visible), a2 = !!(null === (s2 = t3.last()) || void 0 === s2 ? void 0 : s2.visible), u2 = (e2) => {
      var n4;
      return null === (n4 = t3.find((t4) => t4[1].key === String(e2))) || void 0 === n4 ? void 0 : n4[1];
    }, c3 = () => {
      var e2, n4;
      const r4 = null === (n4 = null === (e2 = t3.getVisible()) || void 0 === e2 ? void 0 : e2[0]) || void 0 === n4 ? void 0 : n4[1];
      return r4 ? t3.prev(r4) : void 0;
    }, d3 = () => {
      var e2;
      const n4 = null === (e2 = t3.getVisible().findLast(() => true)) || void 0 === e2 ? void 0 : e2[1];
      return n4 ? t3.next(n4) : void 0;
    }, h3 = null === (i2 = null == n3 ? void 0 : n3.boundary) || void 0 === i2 ? void 0 : i2.current;
    return { getItemById: u2, getItemElementById: B, getItemByIndex: (e2) => {
      var n4;
      return null === (n4 = t3.find((t4) => String(t4[1].index) === String(e2))) || void 0 === n4 ? void 0 : n4[1];
    }, getItemElementByIndex: W, getNextElement: d3, getPrevElement: c3, isFirstItemVisible: l2, isItemVisible: (e2) => t3.getVisible().map((e3) => e3[0]).includes(String(e2)), isLastItem: (e2) => t3.last() === u2(e2), isLastItemVisible: a2, scrollNext: (e2, t4, o3, { duration: s3, boundary: i3 = h3 } = {}) => {
      const l3 = null != e2 ? e2 : null == n3 ? void 0 : n3.behavior;
      return O(d3(), l3, t4 || "start", o3 || "nearest", { boundary: i3, duration: null != s3 ? s3 : null == n3 ? void 0 : n3.duration }, r3);
    }, scrollPrev: (e2, t4, o3, { duration: s3, boundary: i3 = h3 } = {}) => {
      const l3 = null != e2 ? e2 : null == n3 ? void 0 : n3.behavior;
      return O(c3(), l3, t4 || "end", o3 || "nearest", { boundary: i3, duration: null != s3 ? s3 : null == n3 ? void 0 : n3.duration }, r3);
    }, useIsVisible: (n4, r4 = false) => {
      const [o3, s3] = import_react.default.useState(r4), i3 = import_react.default.useCallback((e2) => {
        s3(!!(null == e2 ? void 0 : e2.visible));
      }, []);
      return import_react.default.useEffect(() => (t3.subscribe(n4, i3), () => {
        t3.unsubscribe(n4, i3);
      }), [n4, i3]), o3;
    }, scrollToItem: (e2, t4, o3, s3, i3) => {
      var l3;
      return O(e2, null != t4 ? t4 : null == n3 ? void 0 : n3.behavior, o3, s3, Object.assign(Object.assign({ boundary: h3 }, i3), { duration: null !== (l3 = null == i3 ? void 0 : i3.duration) && void 0 !== l3 ? l3 : null == n3 ? void 0 : n3.duration }), r3);
    } };
  }(oe, { duration: h2, behavior: p2, boundary: te }, _2), [oe, h2, p2, _2]), ue = import_react.default.useCallback(() => Object.assign(Object.assign({}, ae), { items: oe, scrollContainer: te }), [ae, oe, te]), [ce, de] = import_react.default.useState(() => ue());
  (({ context: t3, onInit: n3, onUpdate: r3 }) => {
    const o2 = import_react.default.useCallback(() => n3(t3), [n3, t3]), s2 = import_react.default.useCallback(() => r3(t3), [r3, t3]), { items: i2 } = t3;
    import_react.default.useEffect(() => (i2.subscribe(f.onInit, o2), i2.subscribe(f.onUpdate, s2), () => {
      i2.unsubscribe(f.onInit, o2), i2.unsubscribe(f.onUpdate, s2);
    }), [i2, o2, s2]);
  })({ context: ce, onInit: b2, onUpdate: y2 }), import_react.default.useEffect(() => de(ue()), [ue]), import_react.default.useEffect(() => {
    L(F2) ? F2.current = ce : F2(ce);
  }, [ce, F2]);
  const he = import_react.default.useCallback((e2) => I2(ce, e2), [I2, ce]), fe = import_react.default.useCallback((e2) => R2(ce, e2), [R2, ce]), ve = import_react.default.useMemo(() => `${o} ${U2}`, [U2]), me = import_react.default.useMemo(() => `${T2}${Y2 ? " rtl" : v}`, [Y2, T2]);
  return import_react.default.createElement("div", { className: ve, onWheel: fe, onMouseDown: null == w2 ? void 0 : w2(ce), onMouseLeave: null == C2 ? void 0 : C2(ce), onMouseUp: null == M2 ? void 0 : M2(ce), onMouseMove: null == E2 ? void 0 : E2(ce), onTouchStart: null == x2 ? void 0 : x2(ce), onTouchMove: null == k2 ? void 0 : k2(ce), onTouchEnd: null == N2 ? void 0 : N2(ce), ref: ie }, import_react.default.createElement(P.Provider, { value: ce }, import_react.default.createElement("div", { className: i }, Z2), import_react.default.createElement("div", { className: s }, import_react.default.createElement("div", { className: l }, q2), import_react.default.createElement(A, { className: me, onScroll: he, scrollRef: te, containerRef: $2 }, import_react.default.createElement(V, { refs: ne, itemClassName: H2 }, r2)), import_react.default.createElement("div", { className: a }, G2)), import_react.default.createElement("div", { className: u }, ee)));
}
export {
  Z as ScrollMenu,
  P as VisibilityContext,
  p as constants,
  F as getItemsPos,
  G as slidingWindow
};
//# sourceMappingURL=react-horizontal-scrolling-menu.js.map
